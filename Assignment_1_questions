* [total_product] given a queue, output the product of every element
* [bellow_n_property] given a function from the aliens to bool and an alien n, generate the queue of all aliens bellow n in decreasing order for which f holds
* [map] given function f from aliens to aliens, and a queue, output the result of applying f to each element of the queue
* [eq] check whether two aliens are syntactically the same
* [is_member] check whether alien x is a member of queue w
* [elim] given an alien and a queue, output the result of removing every occurrence of said alien from the queue
* [count] given a list w and a number n, output how many times n appears in w
* [join] given two queues, return their concatenation
* [append] given a queue and an alien, return the result of placing the alien at the front of the queue (where the front is the right-most part) - note: this one doesn't need to be recursive
* [reverse] given a queue, output the queue in reverse order
* [repeat] given an alien k and another alien n, output the queue of length k consisting purely of n's
* [repeat_itself] given a queue w, output the queue where the each element n of w occurs n times in a row, and in order - for example: repeat_itself [2 ; 1 ; 3] = [2 ; 2 ; 1 ; 3 ; 3 ; 3], where I represented queues in an easier-to-read way
* [max] given two aliens, output the biggest - note: you use the less-than relation already defined; not necessarily recursive
* [max_element] given a queue, output its maximum element, and assume (max_element Nil) = O
* [queue_eq] given two queues, decide whether they are equal
* [range] given two aliens left, right, output the queue with all the aliens between left and right, including both; or the empty list if left > right - Hint: the thing that is getting smaller is (right - left)
